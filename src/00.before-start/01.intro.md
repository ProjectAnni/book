# 前言

## 云音乐

相信大家都有过这样的经历，在各个音乐平台之间挣扎的经历。常常是平台 A 下架了某一首歌，平台 B 依靠独占吸收来自平台 A 的难民。

这种现象很普遍，倒不如说在版权时代这是再正常不过的风景了。没有版权就不能上架，天经地义的事情。平台不过是希望吸引流量又不希望承担流量带来的法律风险罢了，否则一开始又为何要上架呢？

罢了，**下载到本地**听吧。

## 本地音乐

本地音乐的来源就非常广泛了。

一是从各大云音乐平台上下载得到的音频。其是否存在加密并不是什么麻烦的事情，因为**音乐终究是要播放的**，最不济你从操作系统层面把送给音频 API 的每一个采样都截下来不就拿到 `wav` 了吗（笑）

二是各大公网音乐包，比如 `[Nemuri]` 的合集。这种合集的特点是音乐全，格式整齐，通常以统一的格式进行分享（如 `FLAC`、`MP3` 等）。

有了音频文件，再配上音乐播放器就可以和云音乐一样听歌了。本地音乐的一大缺点在于更新，没有了云音乐运营，一切的一切都要靠你自己了。

当然了，这并不是本地音乐唯一的问题。**本地**音乐**最大的问题**恰恰在于**本地**。且不论本地音乐增多后多端的存储成本，单单是音乐的同步就够你喝一壶的。就以基本的 `PC`、手机、平板三端同步为例，你需要在这三台设备之间反复横跳——一旦某一台设备没有同步，而你恰巧想要听某一张新发售的专辑——噩梦就降临了。

于是，我们发现，云音乐恰巧是为了解决这些痛点而存在的。那我们要回到云音乐平台吗？

## 自建音乐平台

既希望得到本地音乐的便利，又想要云音乐的便利，这就是自建音乐平台的意义所在了。

最常见的自建音乐平台应该就是 `Airsonic` 了，这是一个用 `Java` 写成，基于 `Subsonic` 的最后一个开源版本 `fork` 而出的项目，而 `Subsonic` 则是著名的自建音乐平台。

`Airsonic` 的存在已经能够满足很多人的需求了，但它还是无法完全满足我当前的需求，原因有以下几点：

1. `Airsonic` 的编写语言是 `Java`，其需要的资源对小型 `VPS` 而言还是太多了。以我目前运行的 `Docker` 为例，没有任何人使用的情况下，基本内存占用维持在 `800MiB` 左右。
2. 自建音乐平台需要服务器有较大的硬盘空间，而这一点面对只会增多不会减少的音乐资源难以永久实现。目前我整理的音乐资源有 `129GiB`，这对于我部署 `Airsonic` 的 `20G` 小鸡肯定是不现实的。
3. 为了应对硬盘问题，我使用了 `rclone` 挂载。但在音乐更新后，`Airsonic` 需要花费大量的时间（小时级别）重新扫描整个音频目录，读取每一个音频文件的元数据。这么长的时间差完全不能满足「马上就听」的需求。
4. `Airsonic` 支持部分更新，根据目录和文件的 `lastModifiedTime` 决定是否扫描。但 `Google Drive` 对于这部分的实现并不遵循一般文件系统的行为，对内层文件的更新并不会导致外层目录的修改时间变化，宣告了 `Airsonic` 的这个特性完全无法使用。
5. `Airsonic` 诸如音乐上传、下载、`last.fm` 的功能是我不需要的，而且没有办法完全关闭。**使用这些功能可能会导致未定义行为**（如上传到 `rclone` 挂载的目录可能会打乱原本的目录结构）。尽管我可以不使用这些功能，但我不能要求和我一起整理资源，共用平台的朋友永远都不使用这些功能。
6. 更新缓慢，`Bug` 丛生。尽管有另一个 `fork` 但问题还是很多，且对我而言维护起来过于困难。

当然了，多多少少还有一些没有列出来的问题。由于这些问题的存在，最终促使我决定在另一个意义上**自建**音乐平台：自己造轮子。

那既然都已经自建了，**我的想法**就是**做多不如做少，做少不如做全**。这句话的前半句是指**做太多没用的**不如**只做核心的一少部分**，而后半句则指做太少事情不如**把想做的都做全**。
