# 缓存

对于存储于云端的音频而言，每次用户请求都重新下载的成本是非常大的。因此，我们需要一种对文件的缓存机制。

## 需求

这种缓存机制**必须**满足的需求如下：

- 缓存命中[^1]: 当缓存**命中**时，直接返回文件
- 缓存缺失[^2]: 当缓存**缺失**时，下载缺失文件
- 缓存饱和[^3]: 当缓存区域**已满**时，选择一种策略，删除一些文件

有这三者，展开的细节需求有：

- 缓存复用[^4]: 当该文件**正在缓存**时，新进入的请求能实时获取部分缓存的文件内容
- 正常删除[^5]: 当缓存区域已满时，**对文件的删除**不能影响正在传输的请求

## 上层接口

对于上层应用，我们只需要向其暴露**读取**的接口即可。当缓存命中[^1]时，直接返回缓存的内容；而对于缓存缺失[^2]的情况，则将新数据写入缓存并读取。定义如下：

```rust
async fn fetch(
        &self,
        key: String,
        on_miss: impl Future<Output=Result<BackendReaderExt, BackendError>>,
    ) -> Result<BackendReaderExt, BackendError> {
    // ignored
}
```

当缓存命中时，`on_miss` 将不会被调用（`.await`）。

## 中层逻辑

对于中层实现，我们需要将缓存的状态分为几个大类：

- 缓存完成：表示文件已完全缓存，可以直接读取
- 缓存部分完成：表示文件正在缓存，文件以分块形式存在
- 缓存